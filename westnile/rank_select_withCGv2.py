#usage:f_svm.py traingingset testset
#Author: WangKai  2011.9.21

import os, sys, traceback
from svmutil import *
import random
import copy
import math
from subprocess import *

global c_begin, c_end, c_step, g_begin, g_end, g_step
c_begin, c_end, c_step = -10,  10, 1
g_begin, g_end, g_step = -10,  10, 1


def proc_argv(argv = sys.argv):
    usage = "Usage: python file.py -minL int -maxL int [-log2c begin,end,step] [-log2g begin,end,step] trainingset testset"
    minL=5
    maxL=50
    global c_begin, c_end, c_step
    global g_begin, g_end, g_step
    if len(argv) < 2:
        print "This script do SVM classification modeling with an increasing number of top best descriptors and find best c,g without grid.py provided by libsvm."
        print "                                                             Write by WangKai"
        print(usage)
        print "-minL  int                   min number of descriptors to use,default is 5"
        print "-maxL  int                   max number of descriptors to use,default is 50"
        print "-log2c begin,end,step        Range of C for libsvm modeling selection, default: -10, 10, 1"
        print "-log2g begin,end,step        Range of G for libsvm modeling selection, default: -10, 10, 1"
        print "trainingset and testset file are at the end of the arguments. They're blank or '\\t' separated files that can be generated by ADRIANNA.Code"
        sys.exit(1)
    
    i = 1
    while i < len(argv) - 1:
        if argv[i] == "-minL":
            i = i + 1
            minL = argv[i]
        elif argv[i]== "-maxL":
            i = i + 1
            maxL = argv[i]
        elif argv[i] == "-log2c":
            i = i + 1
            (c_begin,c_end,c_step) = map(float,argv[i].split(","))
        elif argv[i] == "-log2g":
            i = i + 1
            (g_begin,g_end,g_step) = map(float,argv[i].split(","))
        elif argv[i] in ('-c','-g'):
            print("Option -c and -g are renamed.")
            print(usage)
            sys.exit(1)
        i=i+1
    test_file=argv[-1]
    train_file = argv[-2]
    c_begin=int(c_begin)
    c_end =int(c_end)
    c_step=int(c_step)
    g_begin=int(g_begin)
    g_end =int(g_end)
    g_step=int(g_step)

    return  train_file,test_file,minL,maxL


def descriptor_select(data,all_descriptor,num):
    result=[]
    compound=len(data)
    descriptor_content=[i for i in range(num)]
    max=len(all_descriptor)
    descriptor_content.append(all_descriptor[max-1])
    
    for i in range(compound):
        temp=[]
        for j in range(num+1):
            try:
                temp.append(float(data[i][descriptor_content[j]]))
            except:
                print i


        result.append(temp)
    return (result,descriptor_content)

def get_list (all,l):
    limit=len(all)
    column=[]
    for i in range(limit):
        column.append(float(all[i][l]))
    return column        

def compress (column,max,min):
    copy_c=copy.deepcopy(column)
    copy_c.sort()
    #min=float(copy_c[0])
    #max=float(copy_c[len(copy_c)-1])
    limit=len(column)
    for i in range(limit):
        print column
        column[i]=(column[i]-float(min))/(float(max)-float(min))*0.8+0.1
    return column

def normalized (exaple,dmax,dmin):
    column=[]
    temp=copy.deepcopy(exaple)
    long=len(exaple)
    long_len=len(exaple[0])
    for i in range(long_len-1):
        list_c=get_list(exaple,i)
        list_c=compress(list_c,dmax[i],dmin[i])
        for j in range(long):
            temp[j][i]=(list_c[j])
    return temp
    
def get_pred_label(train_y, train_x, test_y, test_x, param):
	model = svm_train(train_y, train_x, param)
	py, evals, deci = svm_predict(test_y, test_x, model)
	return py,evals[0]


def Tosvm (temp,file,dmax,dmin):
    temp_temp=normalized(temp,dmax,dmin)
    end=len(temp_temp)
    long=len(temp_temp[1])
    
    for i in range(end):
        file.write(str(temp_temp[i][long-1])+'\t')
        for j in range(long-1):
            file.write(str(int(j+1))+':'+str(temp_temp[i][j]))
            file.write('%s' % '\n' if j==long-2 else '\t')
     
def random_split (data,splitset,number):
    train=[]
    test=[]
    compound=len(data)
    for i in range(compound):
        if i in splitset[number]:
            test.append(data[i])
        else:
            train.append(data[i])
    return train,test

def get_Accs(ty,pv):
    if len(ty) != len(pv):
        raise ValueError("len(ty) must equal to len(pv)")
    tp = tn = fp = fn = 0
    for v, y in zip(pv, ty):
        if y == v:
            if y == 1:
                tp += 1
            else:
                tn += 1
        else:
            if y == 1:
                fn +=1
            else:
                fp +=1
    tp=float(tp)
    tn=float(tn)
    fp=float(fp)
    fn=float(fn)

    MCC_x = tp*tn-fp*fn
    a = (tp+fp)*(tp+fn)*(tn+fp)*(tn+fn)
    MCC_y = float(math.sqrt(a))
    if MCC_y == 0:
        MCC = 0
    else:
        MCC = float(MCC_x/MCC_y)
    try:
        Acc_p=tp/(tp+fn)
    except:
        Acc_p=0
        
    try:
        Acc_n=tn/(tn+fp)
    except:
        Acc_n=0
    return (MCC, Acc_p , Acc_n)
       
def libsvm (tempfile_train,tempfile_test,result,loop):
    global c_begin, c_end, c_step
    global g_begin, g_end, g_step
    trainfile=tempfile_train
    testfile=tempfile_test
    best_c=best_g=0.0
    best_rate_train=best_rate_test=0.0
    Pathname=os.path.split(trainfile)[0]+'\\'
    file_name = os.path.split(trainfile)[1]
    filename=file_name.split('.')[0]
    #scaled_file = Pathname + file_name + ".scale"
    model_file = Pathname +  filename + ".model"
    #range_file = Pathname +  file_name + ".range"

    file_name = os.path.split(testfile)[1]
    filename=file_name.split('.')[0]
    '''
    predict_test_file = Pathname + filename + ".predict"
    selfpredict_test_file = Pathname + filename + ".selfpredict"
    '''
    train_y, train_x = svm_read_problem(trainfile)
    test_y, test_x = svm_read_problem(testfile)

    for i in range(int(c_begin), int(c_end), int(c_step)):
        for j in range(g_begin, g_end, g_step):
            c=2**(i)
            g=2**(j)
            param="-c "+str(c)+" -g "+str(g)
            
            pv,acc_test = get_pred_label(train_y, train_x, test_y, test_x, param)
            if acc_test>best_rate_test:
                best_rate_test=acc_test
                bestpv=pv
                pv,acc_train = get_pred_label(train_y, train_x, train_y, train_x, param)
                best_rate_train=acc_train
                best_c=c
                best_g=g
    print ("Loop=%d" %loop)
    print("c=%s, g=%s, train=%s test=%s" % (best_c, best_g, best_rate_train,best_rate_test))
    MCC ,Acc_p,Acc_n = get_Accs(test_y,bestpv)
    result.write("%s\t%s\t%s\t%s\t%s\t%s\t%s\n" % (best_rate_train, best_rate_test, best_c, best_g, MCC,Acc_p,Acc_n))

    
    
def readfileLine(file):
    flist = []
    for line in file.readlines():
        if (line!='' and line!=' ' and line!='\n'):
            flist.append(line.strip().split())
    return flist
    
    
    
    
    

def main():
    train_file,test_file,minL,maxL = proc_argv()
    print "Loop from %s to %s" % (str(minL),str(maxL))
    loop=int(minL)
    assert os.path.exists(train_file),"training file not found"
    assert os.path.exists(test_file),"test file not found"
    '''
    svmtrain_exe = r"D:\libsvm3\windows\svm-train.exe"
    svmpredict_exe = r"D:\libsvm3\windows\svm-predict.exe"
    gnuplot_exe = r"D:\gnuplot\bin\pgnuplot.exe"
    grid_py = r"D:\libsvm3\tools\grid.py"
    
    assert os.path.exists(svmtrain_exe),"svm-train executable not found"
    assert os.path.exists(svmpredict_exe),"svm-predict executable not found"
    assert os.path.exists(gnuplot_exe),"gnuplot executable not found"
    assert os.path.exists(grid_py),"grid.py not found"
    '''
    
    Pathname=os.path.split(train_file)[0]+'\\'
    '''
    file_name = os.path.split(train_file)[1]
    filename=file_name.split('.')[0]
    model_file = Pathname +  filename + ".model"
    selfpredict_test_file = Pathname + filename + ".selfpredict"
    result_file=Pathname + "rank_result.txt"
    file_name = os.path.split(test_file)[1]
    filename=file_name.split('.')[0]
    predict_test_file = Pathname + filename + ".predict"
    '''
    result_file=Pathname + "rank_result.txt"
    result=open(result_file,'w')
    fobj1=open(train_file,'r')
    fobj2=open(test_file,'r')
    allInput_train=[(line.strip()).split() for line in fobj1.readlines()]
    allInput_test=[(line.strip()).split() for line in fobj2.readlines()]

    #allInput_train = readfileLine(fobj1)
    #allInput_test = readfileLine(fobj2)
    fobj1.close()
    fobj2.close()
    
    title_Input=allInput_train[0]
    DESCRIPTOR=len(allInput_train[0])
    COMPOUND_train=len(allInput_train)
    COMPOUND_test=len(allInput_test)
    all_descriptor=[i for i in range(DESCRIPTOR)]
    print all_descriptor
    data_train=[allInput_train[i] for i in range(1,COMPOUND_train)]
    data_test=[allInput_test[i] for i in range(1,COMPOUND_test)]
    result.write("Num_of_des\tacc_train\tacc_test\tc\tg\tMCC\tACC_p\tACC_n\n")
    dmax=[]
    dmin=[]
    #DESCRIPTOR=1
    for i in range (DESCRIPTOR):
        midn=(float(data_train[0][i]))
        midx=(float(data_train[0][i]))
        for j in range(COMPOUND_train-1):
            '''
            print data_train[j][i]
            print midn
            print midx
            print type(midn),type(midx),type(data_train[j][i])
            '''

            if float(data_train[j][i])>=midx:
                #print "inside"
                midx=float(data_train[j][i])
            if float(data_train[j][i])<=midn:
                #print "fuck!"
                midn=float((data_train[j][i]))

                
        dmax.append(midx)
        dmin.append(midn)

    #print dmax[0]
    #print dmin[0]
    best_descriptor=[]
    while loop<=int(maxL):
        #print fold
        print "N=%d" % loop
        train_temp,traincontent=descriptor_select(data_train,all_descriptor,loop)
        test_temp,testcontent=descriptor_select(data_test,all_descriptor,loop)
        result.write("N=%s\t" % str(loop))
        print "pathname"
        print Pathname
        tempfile_train=Pathname+r"\temptrain.txt"
        tempfile_test=Pathname+r"\temptest.txt"    
        fobj2=open(tempfile_train,'w')
        Tosvm(train_temp,fobj2,dmax,dmin)
        fobj3=open(tempfile_test,'w')
        Tosvm(test_temp,fobj3,dmax,dmin)
        fobj2.close()
        fobj3.close()
        libsvm(tempfile_train,tempfile_test,result,loop)
        
        '''
        cross=5
        libsvm(tempfile_train,tempfile_test,result,cross,grid_py,svmtrain_exe,svmpredict_exe,gnuplot_exe)
        result.write("\n   \t")
        cross=10
        libsvm(tempfile_train,tempfile_test,result,cross,grid_py,svmtrain_exe,svmpredict_exe,gnuplot_exe)
        result.write("\n")
        '''
        loop+=1
        

    result.close()        

    

if __name__ == '__main__':
	main()
	raw_input('Press input to exit')
